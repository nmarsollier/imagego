
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nmarsollier/imagego/docs/docs.go (100.0%)</option>
				
				<option value="file1">github.com/nmarsollier/imagego/image/dao.go (87.5%)</option>
				
				<option value="file2">github.com/nmarsollier/imagego/image/resize.go (93.8%)</option>
				
				<option value="file3">github.com/nmarsollier/imagego/image/schema.go (55.6%)</option>
				
				<option value="file4">github.com/nmarsollier/imagego/image/service.go (78.9%)</option>
				
				<option value="file5">github.com/nmarsollier/imagego/image/test_tools.go (100.0%)</option>
				
				<option value="file6">github.com/nmarsollier/imagego/log/logger.go (29.2%)</option>
				
				<option value="file7">github.com/nmarsollier/imagego/log/test_tools.go (100.0%)</option>
				
				<option value="file8">github.com/nmarsollier/imagego/main.go (0.0%)</option>
				
				<option value="file9">github.com/nmarsollier/imagego/rabbit/consume_logout.go (0.0%)</option>
				
				<option value="file10">github.com/nmarsollier/imagego/rest/get_image_id.go (100.0%)</option>
				
				<option value="file11">github.com/nmarsollier/imagego/rest/get_image_id_jpeg.go (100.0%)</option>
				
				<option value="file12">github.com/nmarsollier/imagego/rest/image_tools.go (89.5%)</option>
				
				<option value="file13">github.com/nmarsollier/imagego/rest/post_image.go (80.0%)</option>
				
				<option value="file14">github.com/nmarsollier/imagego/rest/router.go (60.0%)</option>
				
				<option value="file15">github.com/nmarsollier/imagego/rest/server/authorization.go (89.5%)</option>
				
				<option value="file16">github.com/nmarsollier/imagego/rest/server/error.go (60.0%)</option>
				
				<option value="file17">github.com/nmarsollier/imagego/rest/server/logger.go (93.3%)</option>
				
				<option value="file18">github.com/nmarsollier/imagego/rest/server/server.go (100.0%)</option>
				
				<option value="file19">github.com/nmarsollier/imagego/rest/server/test_utils.go (81.8%)</option>
				
				<option value="file20">github.com/nmarsollier/imagego/security/dao.go (81.8%)</option>
				
				<option value="file21">github.com/nmarsollier/imagego/security/service.go (69.2%)</option>
				
				<option value="file22">github.com/nmarsollier/imagego/security/test_utils.go (100.0%)</option>
				
				<option value="file23">github.com/nmarsollier/imagego/tools/env/env.go (100.0%)</option>
				
				<option value="file24">github.com/nmarsollier/imagego/tools/errs/rest_error.go (100.0%)</option>
				
				<option value="file25">github.com/nmarsollier/imagego/tools/errs/validation.go (44.4%)</option>
				
				<option value="file26">github.com/nmarsollier/imagego/tools/httpx/client.go (75.0%)</option>
				
				<option value="file27">github.com/nmarsollier/imagego/tools/httpx/client_mocks.go (100.0%)</option>
				
				<option value="file28">github.com/nmarsollier/imagego/tools/redisx/client.go (50.0%)</option>
				
				<option value="file29">github.com/nmarsollier/imagego/tools/redisx/client_mocks.go (100.0%)</option>
				
				<option value="file30">github.com/nmarsollier/imagego/tools/strs/json.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Nestor Marsollier",
            "email": "nmarsollier@gmail.com"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/rabbit/logout": {
            "get": {
                "description": "Escucha de mensajes logout desde auth.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Rabbit"
                ],
                "summary": "Mensage Rabbit",
                "parameters": [
                    {
                        "description": "Estructura general del mensage",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rabbit.message"
                        }
                    }
                ],
                "responses": {}
            }
        },
        "/v1/image": {
            "post": {
                "description": "Agrega una nueva imagen al servidor.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Imagen"
                ],
                "summary": "Guardar imagen",
                "parameters": [
                    {
                        "description": "Imagen en base64",
                        "name": "image",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/rest.NewRequest"
                        }
                    },
                    {
                        "type": "string",
                        "description": "bearer {token}",
                        "name": "Authorization",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Logging Correlation Id",
                        "name": "correlation_id",
                        "in": "header",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Imagen",
                        "schema": {
                            "$ref": "#/definitions/rest.NewImageResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errs.ValidationErr"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    }
                }
            }
        },
        "/v1/image/:imageID": {
            "get": {
                "description": "Obtiene una imagen del servidor en formato base64",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Imagen"
                ],
                "summary": "Obtener imagen",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Logging Correlation Id",
                        "name": "correlation_id",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "[160|320|640|800|1024|1200]",
                        "name": "Size",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "ID de la imagen",
                        "name": "imageID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Informacion de la Imagen",
                        "schema": {
                            "$ref": "#/definitions/image.Image"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errs.ValidationErr"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    }
                }
            }
        },
        "/v1/image/:imageID/jpeg": {
            "get": {
                "description": "Obtiene una imagen del servidor en formato jpeg.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "image/jpeg"
                ],
                "tags": [
                    "Imagen"
                ],
                "summary": "Obtener jpeg",
                "parameters": [
                    {
                        "type": "string",
                        "description": "Logging Correlation Id",
                        "name": "correlation_id",
                        "in": "header",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "[160|320|640|800|1024|1200]",
                        "name": "Size",
                        "in": "path",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "ID de la imagen",
                        "name": "imageID",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Imagen",
                        "schema": {
                            "type": "file"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/errs.ValidationErr"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/server.ErrorData"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "errs.ValidationErr": {
            "type": "object",
            "properties": {
                "messages": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/errs.errField"
                    }
                }
            }
        },
        "errs.errField": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "path": {
                    "type": "string"
                }
            }
        },
        "image.Image": {
            "type": "object",
            "required": [
                "id",
                "image"
            ],
            "properties": {
                "id": {
                    "type": "string"
                },
                "image": {
                    "type": "string"
                }
            }
        },
        "rabbit.message": {
            "type": "object",
            "properties": {
                "correlation_id": {
                    "type": "string",
                    "example": "123123"
                },
                "message": {
                    "type": "string",
                    "example": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbklEIjoiNjZiNjBlYzhlMGYzYzY4OTUzMzJlOWNmIiwidXNlcklEIjoiNjZhZmQ3ZWU4YTBhYjRjZjQ0YTQ3NDcyIn0.who7upBctOpmlVmTvOgH1qFKOHKXmuQCkEjMV3qeySg"
                }
            }
        },
        "rest.NewImageResponse": {
            "type": "object",
            "required": [
                "id"
            ],
            "properties": {
                "id": {
                    "type": "string"
                }
            }
        },
        "rest.NewRequest": {
            "type": "object",
            "required": [
                "image"
            ],
            "properties": {
                "image": {
                    "type": "string"
                }
            }
        },
        "server.ErrorData": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:3001",
        BasePath:         "/v1",
        Schemes:          []string{},
        Title:            "ImageGo",
        Description:      "Microservicio de Imagenes.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov8" title="1">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package image

import (
        "github.com/nmarsollier/imagego/log"
        "github.com/nmarsollier/imagego/tools/errs"
        "github.com/nmarsollier/imagego/tools/redisx"
)

// Insert agrega una imagen a la db
func Insert(image *Image, ctx ...interface{}) (string, error) <span class="cov8" title="1">{
        if err := image.validateSchema(ctx...); err != nil </span><span class="cov0" title="0">{
                log.Get(ctx...).Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">client := redisx.Get(ctx...)
        err := client.Set(image.ID, image.Image, 0).Err()
        if err != nil </span><span class="cov8" title="1">{
                log.Get(ctx...).Error(err)
                return "", err
        }</span>

        <span class="cov8" title="1">return image.ID, nil</span>
}

// Find encuentra y devuelve una imagen desde la base de datos
func find(imageID string, ctx ...interface{}) (*Image, error) <span class="cov8" title="1">{
        client := redisx.Get(ctx...)
        data, err := client.Get(imageID).Result()
        if err != nil </span><span class="cov8" title="1">{
                log.Get(ctx...).Error(err)
                return nil, errs.NotFound
        }</span>

        <span class="cov8" title="1">result := Image{
                ID:    imageID,
                Image: data,
        }
        return &amp;result, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package image

import (
        "bytes"
        "encoding/base64"
        "fmt"
        "strings"

        // Package image/jpeg is not used explicitly in the code below,
        // but is imported for its initialization side-effect, which allows
        // image.Decode to understand JPEG formatted images.
        _ "image/gif"
        _ "image/jpeg"
        _ "image/png"

        "github.com/disintegration/imaging"
        "github.com/nmarsollier/imagego/log"
)

func resize(image *Image, size int, ctx ...interface{}) (*Image, error) <span class="cov8" title="1">{
        str := image.Image[strings.Index(image.Image, ",")+1:]

        reader := base64.NewDecoder(base64.StdEncoding, strings.NewReader(str))

        img, err := imaging.Decode(reader)
        if err != nil </span><span class="cov0" title="0">{
                log.Get(ctx...).Error(err)
        }</span>
        <span class="cov8" title="1">bounds := img.Bounds()
        if bounds.Size().X &lt;= size </span><span class="cov8" title="1">{
                return &amp;Image{
                        ID:    buildSizeID(image.ID, size),
                        Image: image.Image,
                }, nil
        }</span>

        // Resize srcImage to width = 800px preserving the aspect ratio.
        <span class="cov8" title="1">dstImage := imaging.Resize(img, size, 0, imaging.Lanczos)

        var buffer bytes.Buffer
        writer := base64.NewEncoder(base64.StdEncoding, &amp;buffer)
        imaging.Encode(writer, dstImage, imaging.JPEG, imaging.JPEGQuality(70))
        writer.Close()

        result := Image{
                ID:    buildSizeID(image.ID, size),
                Image: "data:image/jpeg;base64," + buffer.String(),
        }
        return &amp;result, nil</span>
}

func buildSizeID(imageID string, size int) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s_%d", imageID, size)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package image

import (
        "strings"

        "github.com/go-playground/validator/v10"
        "github.com/nmarsollier/imagego/log"
        "github.com/nmarsollier/imagego/tools/errs"
        uuid "github.com/satori/go.uuid"
)

// Image estructura de la imagen
type Image struct {
        ID    string `json:"id"  validate:"required"`
        Image string `json:"image"  validate:"required"`
}

// New crea una nueva imagen
func New(img string) *Image <span class="cov8" title="1">{
        return &amp;Image{
                ID:    uuid.NewV4().String(),
                Image: img,
        }
}</span>

// ErrData la imagen no parece valida
var ErrData = errs.NewValidation().Add("image", "invalid")

func (e *Image) validateSchema(ctx ...interface{}) error <span class="cov8" title="1">{
        validate := validator.New()
        if err := validate.Struct(e); err != nil </span><span class="cov0" title="0">{
                log.Get(ctx...).Error(err)
                return err
        }</span>
        <span class="cov8" title="1">if !strings.Contains(e.Image, "data:image/") </span><span class="cov0" title="0">{
                log.Get(ctx...).Error(ErrData)
                return ErrData
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package image

import (
        "github.com/nmarsollier/imagego/tools/errs"
)

// ErrSize el tamaño es incorrecto
var ErrSize = errs.NewValidation().Add("size", "invalid")

// Find busca una imagen para un tamaño en particular
func Find(imageID string, size int, ctx ...interface{}) (*Image, error) <span class="cov8" title="1">{
        if size &lt;= 0 </span><span class="cov8" title="1">{
                return find(imageID, ctx...)
        }</span>

        <span class="cov8" title="1">sizedID := buildSizeID(imageID, size)

        // Busco el tamaño justo de imagen
        image, err := find(sizedID, ctx...)
        if err != nil &amp;&amp; err != errs.NotFound </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                return image, nil
        }</span>

        <span class="cov8" title="1">return findAndResize(imageID, size, ctx...)</span>
}

func findAndResize(imageID string, size int, ctx ...interface{}) (*Image, error) <span class="cov8" title="1">{
        // No se encuentra el tamaño buscado, buscamos la original,
        // y le ajustamos el tamaño, guardamos...
        image, err := find(imageID, ctx...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">image, err = resize(image, size, ctx...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">_, err = Insert(image, ctx...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return image, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package image

func TestImage() *Image <span class="cov8" title="1">{
        return New("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII=")
}</span>

func TestInvalidImage() *Image <span class="cov8" title="1">{
        return New("___")
}</span>

func TestResizeImage() *Image <span class="cov8" title="1">{
        return New("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKUAAAClCAIAAACySaqNAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AYht+mSou0dLCDiEOE6mQXFXGsVShChVArtOpgcukfNGlJUlwcBdeCgz+LVQcXZ10dXAVB8AfE2cFJ0UVK/C4ptIjx4O4e3vvel7vvAKFVZZrZlwA03TIyqaSYy6+KgVcEEUGY1lGZmfU5SUrDc3zdw8f3uzjP8q77c4TVgskAn0icYHXDIt4gntm06pz3iaOsLKvE58QTBl2Q+JHristvnEsOCzwzamQz88RRYrHUw0oPs7KhEU8Tx1RNp3wh57LKeYuzVm2wzj35C0MFfWWZ6zRHkMIiliBBhIIGKqjCQpx2nRQTGTpPeviHHb9ELoVcFTByLKAGDbLjB/+D3701i1OTblIoCfS/2PbHGBDYBdpN2/4+tu32CeB/Bq70rr/WAmY/SW92tdgRENkGLq67mrIHXO4AQ0912ZAdyU9TKBaB9zP6pjwweAsMrLl965zj9AHIUq/SN8DBITBeoux1j3cHe/v2b02nfz9eInKemubWvQAAAAlwSFlzAAAuIwAALiMBeKU/dgAAAAd0SU1FB+gIDw0IOcHU+YsAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAZklEQVR42u3BMQEAAADCoPVPbQdvoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4DD+/AAGTr/KYAAAAAElFTkSuQmCC")
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package log

import (
        "flag"
        "fmt"
        "net"

        "github.com/nmarsollier/imagego/tools/env"
        uuid "github.com/satori/go.uuid"
        "github.com/sirupsen/logrus"
)

const LOG_FIELD_CORRELATION_ID = "correlation_id"
const LOG_FIELD_CONTROLLER = "controller"
const LOG_FIELD_RABBIT_ACTION = "rabbit_action"
const LOG_FIELD_RABBIT_EXCHANGE = "exchange"
const LOG_FIELD_RABBIT_QUEUE = "queue"
const LOG_FIELD_HTTP_METHOD = "http_method"
const LOG_FIELD_HTTP_PATH = "http_path"
const LOG_FIELD_HTTP_STATUS = "http_status"
const LOG_FIELD_SERVER = "server"
const LOG_FIELD_USER_ID = "user_id"
const LOG_FIELD_THREAD = "thread"

type logrusConnectionHook struct {
        conn net.Conn
        fmt  logrus.Formatter
}

func (hook *logrusConnectionHook) Fire(entry *logrus.Entry) error <span class="cov0" title="0">{
        msg, err := hook.fmt.Format(entry)
        if err == nil </span><span class="cov0" title="0">{
                fmt.Println(string(msg))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (hook *logrusConnectionHook) Levels() []logrus.Level <span class="cov0" title="0">{
        return logrus.AllLevels
}</span>
func (hook *logrusConnectionHook) Close() error <span class="cov0" title="0">{
        hook.conn.Close()
        return nil
}</span>

func configureFluent(logger *logrus.Logger) <span class="cov0" title="0">{
        conn, err := net.Dial("tcp", env.Get().FluentUrl)
        if err == nil </span><span class="cov0" title="0">{
                logger.SetFormatter(&amp;logrus.JSONFormatter{})
                logger.SetOutput(conn)
                logger.AddHook(&amp;logrusConnectionHook{
                        conn: conn,
                        fmt: &amp;logrus.TextFormatter{
                                FullTimestamp:  true,
                                ForceColors:    true,
                                DisableSorting: false,
                        },
                })
        }</span>
}

func new() *logrus.Entry <span class="cov8" title="1">{
        inTestMode := flag.Lookup("test.v") != nil
        if inTestMode </span><span class="cov8" title="1">{
                return NewTestLogger()
        }</span>

        <span class="cov0" title="0">logger := logrus.New()
        configureFluent(logger)

        logger.SetLevel(logrus.DebugLevel)
        result := logger.
                WithField(LOG_FIELD_SERVER, "imagego").
                WithField(LOG_FIELD_THREAD, uuid.NewV4().String())
        return result</span>
}

func Get(ctx ...interface{}) *logrus.Entry <span class="cov8" title="1">{
        for _, o := range ctx </span><span class="cov8" title="1">{
                if tc, ok := o.(*logrus.Entry); ok </span><span class="cov8" title="1">{
                        return tc
                }</span>
        }
        <span class="cov8" title="1">return new()</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package log

import "github.com/sirupsen/logrus"

func NewTestLogger() *logrus.Entry <span class="cov8" title="1">{
        logger := logrus.New()
        logger.SetLevel(logrus.DebugLevel)
        return logrus.NewEntry(logger)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "github.com/nmarsollier/imagego/rabbit"
        "github.com/nmarsollier/imagego/rest"
)

//        @title                        ImageGo
//        @version                1.0
//        @description        Microservicio de Imagenes.

//        @contact.name        Nestor Marsollier
//        @contact.email        nmarsollier@gmail.com

// @host                localhost:3001
// @BasePath        /v1
func main() <span class="cov0" title="0">{
        rabbit.Init()
        rest.StartEngine()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package rabbit

import (
        "encoding/json"
        "errors"
        "time"

        "github.com/nmarsollier/imagego/log"
        "github.com/nmarsollier/imagego/security"
        "github.com/nmarsollier/imagego/tools/env"
        uuid "github.com/satori/go.uuid"
        "github.com/streadway/amqp"
)

var ErrChannelNotInitialized = errors.New("channel not initialized")

//        @Summary                Mensage Rabbit
//        @Description        Escucha de mensajes logout desde auth.
//        @Tags                        Rabbit
//        @Accept                        json
//        @Produce                json
//        @Param                        body        body        message        true        "Estructura general del mensage"
//        @Router                        /rabbit/logout [get]
//
// Escucha de mensajes logout desde auth.
func Init() <span class="cov0" title="0">{
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        listenLogout()
                        log.Get().Info("RabbitMQ conectando en 5 segundos.")
                        time.Sleep(5 * time.Second)
                }</span>
        }()
}

func listenLogout() error <span class="cov0" title="0">{
        logger := log.Get().
                WithField(log.LOG_FIELD_CONTROLLER, "Rabbit").
                WithField(log.LOG_FIELD_RABBIT_QUEUE, "auth").
                WithField(log.LOG_FIELD_RABBIT_EXCHANGE, "logout").
                WithField(log.LOG_FIELD_RABBIT_ACTION, "Consume")

        conn, err := amqp.Dial(env.Get().RabbitURL)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        chn, err := conn.Channel()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return err
        }</span>
        <span class="cov0" title="0">defer chn.Close()

        err = chn.ExchangeDeclare(
                "auth",   // name
                "fanout", // type
                false,    // durable
                false,    // auto-deleted
                false,    // internal
                false,    // no-wait
                nil,      // arguments
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">queue, err := chn.QueueDeclare(
                "",    // name
                false, // durable
                false, // delete when unused
                false, // exclusive
                false, // no-wait
                nil,   // arguments
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">err = chn.QueueBind(
                queue.Name, // queue name
                "",         // routing key
                "auth",     // exchange
                false,
                nil)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">mgs, err := chn.Consume(
                queue.Name, // queue
                "",         // consumer
                true,       // auto-ack
                false,      // exclusive
                false,      // no-local
                false,      // no-wait
                nil,        // args
        )
        if err != nil </span><span class="cov0" title="0">{
                logger.Error(err)
                return err
        }</span>

        <span class="cov0" title="0">logger.Info("RabbitMQ conectado")

        go func() </span><span class="cov0" title="0">{
                for d := range mgs </span><span class="cov0" title="0">{
                        newMessage := &amp;message{}
                        body := d.Body
                        logger.Info("Rabbit Consume : ", string(body))

                        err = json.Unmarshal(body, newMessage)
                        if err == nil </span><span class="cov0" title="0">{
                                l := logger.WithField(log.LOG_FIELD_CORRELATION_ID, getCorrelationId(newMessage))
                                security.Invalidate(newMessage.Message, l)
                        }</span> else<span class="cov0" title="0"> {
                                logger.Error(err)
                        }</span>
                }
        }()

        <span class="cov0" title="0">logger.Info("Closed connection: ", &lt;-conn.NotifyClose(make(chan *amqp.Error)))

        return nil</span>
}

type message struct {
        CorrelationId string `json:"correlation_id" example:"123123" `
        Message       string `json:"message" example:"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbklEIjoiNjZiNjBlYzhlMGYzYzY4OTUzMzJlOWNmIiwidXNlcklEIjoiNjZhZmQ3ZWU4YTBhYjRjZjQ0YTQ3NDcyIn0.who7upBctOpmlVmTvOgH1qFKOHKXmuQCkEjMV3qeySg"`
}

func getCorrelationId(c *message) string <span class="cov0" title="0">{
        value := c.CorrelationId

        if len(value) == 0 </span><span class="cov0" title="0">{
                value = uuid.NewV4().String()
        }</span>

        <span class="cov0" title="0">return value</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/imagego/rest/server"
)

//        @Summary                Obtener imagen
//        @Description        Obtiene una imagen del servidor en formato base64
//        @Tags                        Imagen
//        @Accept                        json
//        @Produce                json
//        @Param                        correlation_id        header                string                                true        "Logging Correlation Id"
//        @Param                        Size                        path                string                                true        "[160|320|640|800|1024|1200]"
//        @Param                        imageID                        path                string                                true        "ID de la imagen"
//        @Success                200                                {object}        image.Image                        "Informacion de la Imagen"
//        @Failure                400                                {object}        errs.ValidationErr        "Bad Request"
//        @Failure                401                                {object}        server.ErrorData        "Unauthorized"
//        @Failure                404                                {object}        server.ErrorData        "Not Found"
//        @Failure                500                                {object}        server.ErrorData        "Internal Server Error"
//        @Router                        /v1/image/:imageID [get]
//
// Obtiene una imagen del servidor en formato base64
func initGetImageId() <span class="cov8" title="1">{
        server.Router().GET("/v1/image/:imageID", sendImage)
}</span>

func sendImage(c *gin.Context) <span class="cov8" title="1">{
        data, err := getImage(c)

        if err != nil </span><span class="cov8" title="1">{
                c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(200, data)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package rest

import (
        "encoding/base64"
        "io/ioutil"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/imagego/image"
        "github.com/nmarsollier/imagego/rest/server"
)

//        @Summary                Obtener jpeg
//        @Description        Obtiene una imagen del servidor en formato jpeg.
//        @Tags                        Imagen
//        @Accept                        json
//        @Produce                image/jpeg
//        @Param                        correlation_id        header                string                                true        "Logging Correlation Id"
//        @Param                        Size                        path                string                                true        "[160|320|640|800|1024|1200]"
//        @Param                        imageID                        path                string                                true        "ID de la imagen"
//        @Success                200                                {file}                jpeg                                "Imagen"
//        @Failure                400                                {object}        errs.ValidationErr        "Bad Request"
//        @Failure                401                                {object}        server.ErrorData        "Unauthorized"
//        @Failure                404                                {object}        server.ErrorData        "Not Found"
//        @Failure                500                                {object}        server.ErrorData        "Internal Server Error"
//        @Router                        /v1/image/:imageID/jpeg [get]
//
// Obtiene una imagen del servidor en formato jpeg.
func initGetImageIdJpeg() <span class="cov8" title="1">{
        server.Router().GET("/v1/image/:imageID/jpeg", sendJpegImage)
}</span>

func sendJpegImage(c *gin.Context) <span class="cov8" title="1">{
        image, err := getImage(c)
        if err != nil </span><span class="cov8" title="1">{
                c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">decodedData, err := toJpeg(image)
        if err != nil </span><span class="cov8" title="1">{
                c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">c.Data(200, "image/jpeg", decodedData)</span>
}

func toJpeg(data *image.Image) ([]byte, error) <span class="cov8" title="1">{
        str := data.Image[strings.Index(data.Image, ",")+1:]
        reader := base64.NewDecoder(base64.StdEncoding, strings.NewReader(str))
        return ioutil.ReadAll(reader)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/imagego/image"
        "github.com/nmarsollier/imagego/rest/server"
)

// GetImage devuelve una imagen guardada en formato base64
func getImage(c *gin.Context) (*image.Image, error) <span class="cov8" title="1">{
        imageID := c.Param("imageID")
        size := getSizeParam(c)

        ctx := server.GinCtx(c)
        data, err := image.Find(imageID, size, ctx...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return data, nil</span>
}

func getSizeParam(c *gin.Context) int <span class="cov8" title="1">{
        headerSize, ok := c.GetQuery("Size")
        if !ok </span><span class="cov8" title="1">{
                headerSize = c.GetHeader("Size")
        }</span>

        <span class="cov8" title="1">return normalizeParamSize(headerSize)</span>
}

// normalizeParamSize retorna el tamaño a partir del header
func normalizeParamSize(sizeHeader string) int <span class="cov8" title="1">{
        switch sizeHeader </span>{
        case "160":<span class="cov8" title="1">
                return 160</span>
        case "320":<span class="cov8" title="1">
                return 320</span>
        case "640":<span class="cov8" title="1">
                return 640</span>
        case "800":<span class="cov8" title="1">
                return 800</span>
        case "1024":<span class="cov0" title="0">
                return 1024</span>
        case "1200":<span class="cov0" title="0">
                return 1200</span>
        }
        <span class="cov8" title="1">return 0</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package rest

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/imagego/image"
        "github.com/nmarsollier/imagego/rest/server"
)

// Agrega una nueva imagen al servidor.
//
//        @Summary                Guardar imagen
//        @Description        Agrega una nueva imagen al servidor.
//        @Tags                        Imagen
//        @Accept                        json
//        @Produce                json
//        @Param                        image                        body                NewRequest                        true        "Imagen en base64"
//        @Param                        Authorization        header                string                                true        "bearer {token}"
//        @Param                        correlation_id        header                string                                true        "Logging Correlation Id"
//        @Success                200                                {object}        NewImageResponse        "Imagen"
//        @Failure                400                                {object}        errs.ValidationErr        "Bad Request"
//        @Failure                401                                {object}        server.ErrorData        "Unauthorized"
//        @Failure                404                                {object}        server.ErrorData        "Not Found"
//        @Failure                500                                {object}        server.ErrorData        "Internal Server Error"
//        @Router                        /v1/image [post]
//
// Init inicializa la ruta
func initPostImage() <span class="cov8" title="1">{
        server.Router().POST(
                "/v1/image",
                server.ValidateAuthentication,
                saveImage,
        )
}</span>

func saveImage(c *gin.Context) <span class="cov8" title="1">{
        bodyImage, err := getBodyImage(c)
        if err != nil </span><span class="cov0" title="0">{
                c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">ctx := server.GinCtx(c)
        id, err := image.Insert(image.New(bodyImage), ctx...)
        if err != nil </span><span class="cov8" title="1">{
                c.Error(err)
                return
        }</span>

        <span class="cov8" title="1">c.JSON(200, NewImageResponse{ID: id})</span>
}

func getBodyImage(c *gin.Context) (string, error) <span class="cov8" title="1">{
        body := NewRequest{}

        if err := c.ShouldBindJSON(&amp;body); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return body.Image, nil</span>
}

type NewRequest struct {
        Image string `json:"image" binding:"required"`
}

type NewImageResponse struct {
        ID string `json:"id"  validate:"required"`
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package rest

import (
        "fmt"

        _ "github.com/nmarsollier/imagego/docs"
        "github.com/nmarsollier/imagego/rest/server"
        "github.com/nmarsollier/imagego/tools/env"
)

// StartEngine Runs gin server
func StartEngine() <span class="cov0" title="0">{
        InitRoutes()
        server.Router().Run(fmt.Sprintf(":%d", env.Get().Port))
}</span>

func InitRoutes() <span class="cov8" title="1">{
        initGetImageId()
        initGetImageIdJpeg()
        initPostImage()
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package server

import (
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/imagego/log"
        "github.com/nmarsollier/imagego/security"
        "github.com/nmarsollier/imagego/tools/errs"
)

// ValidateAuthentication validate gets and check variable body to create new variable
// puts model.Variable in context as body if everything is correct
func ValidateAuthentication(c *gin.Context) <span class="cov8" title="1">{
        user, err := validateToken(c)
        if err != nil </span><span class="cov8" title="1">{
                c.Error(err)
                c.Abort()
                return
        }</span>

        <span class="cov8" title="1">ctx := GinCtx(c)
        c.Set("logger", log.Get(ctx...).WithField(log.LOG_FIELD_USER_ID, user.ID))</span>
}

func validateToken(c *gin.Context) (*security.User, error) <span class="cov8" title="1">{
        tokenString, err := getHeaderToken(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errs.Unauthorized
        }</span>

        <span class="cov8" title="1">ctx := GinCtx(c)
        user, err := security.Validate(tokenString, ctx...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs.Unauthorized
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// get token from Authorization header
func getHeaderToken(c *gin.Context) (string, error) <span class="cov8" title="1">{
        tokenString := c.GetHeader("Authorization")
        if strings.Index(tokenString, "bearer ") != 0 </span><span class="cov0" title="0">{
                return "", errs.Unauthorized
        }</span>
        <span class="cov8" title="1">return tokenString[7:], nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package server

import (
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "github.com/nmarsollier/imagego/tools/errs"
)

// ErrorHandler a middleware to handle errors
func ErrorHandler(c *gin.Context) <span class="cov8" title="1">{
        c.Next()

        handleErrorIfNeeded(c)
}</span>

func handleErrorIfNeeded(c *gin.Context) <span class="cov8" title="1">{
        lastErr := c.Errors.Last()
        if lastErr == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">err := lastErr.Err
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">handleError(c, err)</span>
}

// handleError maneja cualquier error para serializarlo como JSON al cliente
func handleError(c *gin.Context, err interface{}) <span class="cov8" title="1">{
        // Compruebo tipos de errores conocidos
        switch value := err.(type) </span>{
        case errs.RestError:<span class="cov8" title="1">
                // Son validaciones hechas con NewCustom
                handleCustom(c, value)</span>
        case errs.Validation:<span class="cov0" title="0">
                // Son validaciones hechas con NewValidation
                c.JSON(400, err)</span>
        case validator.ValidationErrors:<span class="cov0" title="0">
                // Son las validaciones de validator usadas en validaciones de estructuras
                handleValidationError(c, value)</span>
        case error:<span class="cov8" title="1">
                // Otros errores
                c.JSON(500, ErrorData{
                        Error: value.Error(),
                })</span>
        default:<span class="cov0" title="0">
                // No se sabe que es, devolvemos internal
                handleCustom(c, errs.Internal)</span>
        }
}

func handleValidationError(c *gin.Context, validationErrors validator.ValidationErrors) <span class="cov0" title="0">{
        err := errs.NewValidation()

        for _, e := range validationErrors </span><span class="cov0" title="0">{
                err.Add(strings.ToLower(e.Field()), e.Tag())
        }</span>

        <span class="cov0" title="0">c.JSON(400, err)</span>
}

func handleCustom(c *gin.Context, err errs.RestError) <span class="cov8" title="1">{
        c.JSON(err.Status(), err)
}</span>

type ErrorData struct {
        Error string `json:"error"`
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package server

import (
        "github.com/gin-gonic/gin"
        "github.com/nmarsollier/imagego/log"
        uuid "github.com/satori/go.uuid"
        "github.com/sirupsen/logrus"
)

func newGinLogger(c *gin.Context) *logrus.Entry <span class="cov8" title="1">{
        return log.Get().
                WithField(log.LOG_FIELD_CORRELATION_ID, getCorrelationId(c)).
                WithField(log.LOG_FIELD_CONTROLLER, "Rest").
                WithField(log.LOG_FIELD_HTTP_METHOD, c.Request.Method).
                WithField(log.LOG_FIELD_HTTP_PATH, c.Request.URL.Path)
}</span>

func GinLoggerMiddleware(c *gin.Context) <span class="cov8" title="1">{
        logger := newGinLogger(c)

        c.Set("logger", logger)

        c.Next()

        if c.Request.Method != "OPTIONS" </span><span class="cov8" title="1">{
                ctx := GinCtx(c)
                log.Get(ctx...).WithField(log.LOG_FIELD_HTTP_STATUS, c.Writer.Status()).Info("Completed")
        }</span>
}

func ginLogger(c *gin.Context) *logrus.Entry <span class="cov8" title="1">{
        logger, exist := c.Get("logger")
        if !exist </span><span class="cov0" title="0">{
                return newGinLogger(c)
        }</span>
        <span class="cov8" title="1">return logger.(*logrus.Entry)</span>
}

func getCorrelationId(c *gin.Context) string <span class="cov8" title="1">{
        value := c.GetHeader(log.LOG_FIELD_CORRELATION_ID)

        if len(value) == 0 </span><span class="cov8" title="1">{
                value = uuid.NewV4().String()
        }</span>

        <span class="cov8" title="1">return value</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package server

import (
        "time"

        "github.com/gin-contrib/gzip"
        "github.com/gin-gonic/gin"
        cors "github.com/itsjamie/gin-cors"
        _ "github.com/nmarsollier/imagego/docs"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

var engine *gin.Engine = nil

func Router() *gin.Engine <span class="cov8" title="1">{
        if engine != nil </span><span class="cov8" title="1">{
                return engine
        }</span>

        <span class="cov8" title="1">engine = gin.Default()
        engine.Use(gzip.Gzip(gzip.DefaultCompression))
        engine.Use(GinLoggerMiddleware)
        engine.Use(ErrorHandler)

        engine.Use(cors.Middleware(cors.Config{
                Origins:         "*",
                Methods:         "GET, PUT, POST, DELETE",
                RequestHeaders:  "Origin, Authorization, Content-Type, Size",
                ExposedHeaders:  "",
                MaxAge:          50 * time.Second,
                Credentials:     false,
                ValidateHeaders: false,
        }))

        engine.GET("/docs/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        return engine</span>
}

// Obtiene el contexto a serivcios externos
// En prod este contexto esta vacio.
func GinCtx(c *gin.Context) []interface{} <span class="cov8" title="1">{
        var ctx []interface{}
        // mock_ctx solo es para mocks en testing
        if mocks, ok := c.Get("mock_ctx"); ok </span><span class="cov8" title="1">{
                ctx = mocks.([]interface{})
        }</span>

        <span class="cov8" title="1">ctx = append(ctx, ginLogger(c))

        return ctx</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package server

import (
        "bytes"
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "testing"

        "github.com/gin-gonic/gin"
        "gopkg.in/go-playground/assert.v1"
)

// Obtiene Router engine con el contexto de testing adecuado
// mockeando interfaces a serivcios externos
func TestRouter(ctx ...interface{}) *gin.Engine <span class="cov8" title="1">{
        engine = nil
        Router()
        if len(ctx) &gt; 0 </span><span class="cov8" title="1">{
                engine.Use(func(c *gin.Context) </span><span class="cov8" title="1">{
                        c.Set("mock_ctx", ctx)
                        c.Next()
                }</span>)
        }
        <span class="cov8" title="1">return engine</span>
}

// Requests Test functions

func TestGetRequest(url string, tokenString string) (*http.Request, *httptest.ResponseRecorder) <span class="cov8" title="1">{
        req, _ := http.NewRequest("GET", url, bytes.NewBuffer([]byte{}))
        if len(tokenString) &gt; 0 </span><span class="cov8" title="1">{
                req.Header.Add("Authorization", "bearer "+tokenString)
        }</span>
        <span class="cov8" title="1">w := httptest.NewRecorder()
        return req, w</span>
}

func TestDeleteRequest(url string, tokenString string) (*http.Request, *httptest.ResponseRecorder) <span class="cov0" title="0">{
        req, _ := http.NewRequest("DELETE", url, bytes.NewBuffer([]byte{}))
        if len(tokenString) &gt; 0 </span><span class="cov0" title="0">{
                req.Header.Add("Authorization", "bearer "+tokenString)
        }</span>
        <span class="cov0" title="0">w := httptest.NewRecorder()
        return req, w</span>
}

func TestPostRequest(url string, body interface{}, tokenString string) (*http.Request, *httptest.ResponseRecorder) <span class="cov8" title="1">{
        jsonBody, _ := json.Marshal(body)

        req, _ := http.NewRequest("POST", url, bytes.NewBuffer(jsonBody))
        if len(tokenString) &gt; 0 </span><span class="cov8" title="1">{
                req.Header.Add("Authorization", "bearer "+tokenString)
        }</span>
        <span class="cov8" title="1">w := httptest.NewRecorder()
        return req, w</span>
}

// Assertion Functions
func AssertUnauthorized(t *testing.T, w *httptest.ResponseRecorder) <span class="cov8" title="1">{
        assert.Equal(t, http.StatusUnauthorized, w.Code)

        var result map[string]interface{}
        json.Unmarshal(w.Body.Bytes(), &amp;result)

        assert.Equal(t, result["error"], "Unauthorized")
}</span>

func AssertDocumentNotFound(t *testing.T, w *httptest.ResponseRecorder) <span class="cov8" title="1">{
        assert.Equal(t, http.StatusNotFound, w.Code)

        var result map[string]interface{}
        json.Unmarshal(w.Body.Bytes(), &amp;result)
        assert.Equal(t, "Document not found", result["error"])
}</span>

func AssertInternalServerError(t *testing.T, w *httptest.ResponseRecorder) <span class="cov8" title="1">{
        assert.Equal(t, http.StatusInternalServerError, w.Code)
}</span>

func AssertBadRequestError(t *testing.T, w *httptest.ResponseRecorder) <span class="cov0" title="0">{
        assert.Equal(t, http.StatusBadRequest, w.Code)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package security

import (
        "encoding/json"
        "net/http"

        "github.com/go-playground/validator/v10"
        "github.com/nmarsollier/imagego/log"
        "github.com/nmarsollier/imagego/tools/env"
        "github.com/nmarsollier/imagego/tools/errs"
        "github.com/nmarsollier/imagego/tools/httpx"
)

func getRemoteToken(token string, ctx ...interface{}) (*User, error) <span class="cov8" title="1">{
        // Buscamos el usuario remoto
        req, err := http.NewRequest("GET", env.Get().SecurityServerURL+"/v1/users/current", nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Get(ctx...).Error(err)
                return nil, errs.Unauthorized
        }</span>
        <span class="cov8" title="1">req.Header.Add("Authorization", "bearer "+token)
        if corrId, ok := log.Get(ctx...).Data[log.LOG_FIELD_CORRELATION_ID].(string); ok </span><span class="cov8" title="1">{
                req.Header.Add(log.LOG_FIELD_CORRELATION_ID, corrId)
        }</span>

        <span class="cov8" title="1">resp, err := httpx.Get(ctx...).Do(req)
        if err != nil || resp.StatusCode != 200 </span><span class="cov8" title="1">{
                log.Get(ctx...).Error(err)
                return nil, errs.Unauthorized
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        user := &amp;User{}
        err = json.NewDecoder(resp.Body).Decode(user)
        if err != nil </span><span class="cov8" title="1">{
                log.Get(ctx...).Error(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">validate := validator.New()
        if err := validate.Struct(user); err != nil </span><span class="cov0" title="0">{
                log.Get(ctx...).Error(err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return user, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package security

import (
        "time"

        "github.com/nmarsollier/imagego/log"
        "github.com/nmarsollier/imagego/tools/errs"
        gocache "github.com/patrickmn/go-cache"
)

var cache = gocache.New(60*time.Minute, 10*time.Minute)

// Validate valida si el token es valido
func Validate(token string, ctx ...interface{}) (*User, error) <span class="cov8" title="1">{
        // Si esta en cache, retornamos el cache
        if found, ok := cache.Get(token); ok </span><span class="cov0" title="0">{
                if user, ok := found.(*User); ok </span><span class="cov0" title="0">{
                        return user, nil
                }</span>
        }

        <span class="cov8" title="1">user, err := getRemoteToken(token, ctx...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errs.Unauthorized
        }</span>

        // Todo bien, se agrega al cache y se retorna
        <span class="cov8" title="1">cache.Set(token, user, gocache.DefaultExpiration)

        return user, nil</span>
}

// Invalidate invalida un token del cache
func Invalidate(token string, ctx ...interface{}) <span class="cov8" title="1">{
        if len(token) &lt;= 7 </span><span class="cov0" title="0">{
                log.Get(ctx...).Info("Token no valido: ", token)
                return
        }</span>

        <span class="cov8" title="1">cache.Delete(token)
        log.Get(ctx...).Info("Token invalidado: ", token)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package security

import (
        "bytes"
        "io"
        "net/http"

        "github.com/golang/mock/gomock"
        "github.com/nmarsollier/imagego/tools/httpx"
        "github.com/nmarsollier/imagego/tools/strs"
        "go.mongodb.org/mongo-driver/bson/primitive"
)

// Mock Data
func TestUser() *User <span class="cov8" title="1">{
        return &amp;User{
                ID:          primitive.NewObjectID().Hex(),
                Login:       "Login",
                Name:        "Name",
                Permissions: []string{"user"},
        }
}</span>

// Http Mocks
func ExpectHttpToken(mock *httpx.MockHTTPClient, user *User) <span class="cov8" title="1">{
        response := &amp;http.Response{
                StatusCode: http.StatusOK,
                Body:       io.NopCloser(bytes.NewBufferString(strs.ToJson(user))),
        }
        mock.EXPECT().Do(gomock.Any()).Return(response, nil).Times(1)
}</span>

func ExpectHttpUnauthorized(mock *httpx.MockHTTPClient) <span class="cov8" title="1">{
        response := &amp;http.Response{
                StatusCode: http.StatusUnauthorized,
                Body:       io.NopCloser(bytes.NewBufferString("")),
        }
        mock.EXPECT().Do(gomock.Any()).Return(response, nil).Times(1)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package env

import (
        "os"
        "strconv"
)

// Configuration properties
type Configuration struct {
        Port              int    `json:"port"`
        RabbitURL         string `json:"rabbitUrl"`
        RedisURL          string `json:"redisUrl"`
        SecurityServerURL string `json:"securityServerUrl"`
        FluentUrl         string `json:"fluentUrl"`
}

var config *Configuration

func new() *Configuration <span class="cov8" title="1">{
        return &amp;Configuration{
                Port:              3001,
                RabbitURL:         "amqp://localhost",
                RedisURL:          "localhost:6379",
                SecurityServerURL: "http://localhost:3000",
                FluentUrl:         "localhost:24224",
        }
}</span>

// Get Obtiene las variables de entorno del sistema
func Get() *Configuration <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = load()
        }</span>

        <span class="cov8" title="1">return config</span>
}

// Load file properties
func load() *Configuration <span class="cov8" title="1">{
        result := new()

        if value := os.Getenv("REDIS_URL"); len(value) &gt; 0 </span><span class="cov8" title="1">{
                result.RedisURL = value
        }</span>

        <span class="cov8" title="1">if value := os.Getenv("RABBIT_URL"); len(value) &gt; 0 </span><span class="cov8" title="1">{
                result.RabbitURL = value
        }</span>

        <span class="cov8" title="1">if value := os.Getenv("PORT"); len(value) &gt; 0 </span><span class="cov8" title="1">{
                if intVal, err := strconv.Atoi(value); err == nil </span><span class="cov8" title="1">{
                        result.Port = intVal
                }</span>
        }

        <span class="cov8" title="1">if value := os.Getenv("FLUENT_URL"); len(value) &gt; 0 </span><span class="cov8" title="1">{
                result.FluentUrl = value
        }</span>

        <span class="cov8" title="1">if value := os.Getenv("AUTH_SERVICE_URL"); len(value) &gt; 0 </span><span class="cov8" title="1">{
                result.SecurityServerURL = value
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package errs

// Unauthorized el usuario no esta autorizado al recurso
var Unauthorized = NewRestError(401, "Unauthorized")

// NotFound cuando un registro no se encuentra en la db
var NotFound = NewRestError(404, "Document not found")

// AlreadyExist cuando no se puede ingresar un registro a la db
var AlreadyExist = NewRestError(400, "Already exist")

// Internal esta aplicación no sabe como manejar el error
var Internal = NewRestError(500, "Internal server error")

// - Creación de errors -
// NewRestError creates a new errCustom
func NewRestError(status int, message string) RestError <span class="cov8" title="1">{
        return &amp;restError{
                status:  status,
                Message: message,
        }
}</span>

//  - Algunas definiciones necesarias -

// RestError es una interfaz para definir errores custom
type RestError interface {
        Status() int
        Error() string
}

// restError es un error personalizado para http
type restError struct {
        status  int
        Message string `json:"error"`
}

func (e *restError) Error() string <span class="cov8" title="1">{
        return e.Message
}</span>

// Status http status code
func (e *restError) Status() int <span class="cov8" title="1">{
        return e.status
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package errs

import (
        "encoding/json"

        "github.com/nmarsollier/imagego/log"
)

// Validation es una interfaz para definir errores custom
// Validation es un error de validaciones de parameteros o de campos
type Validation interface {
        Add(path string, message string) Validation
        Error() string
}

func NewValidation() Validation <span class="cov8" title="1">{
        return &amp;ValidationErr{
                Messages: []errField{},
        }
}</span>

type ValidationErr struct {
        Messages []errField `json:"messages"`
}

func (e *ValidationErr) Error() string <span class="cov0" title="0">{
        body, err := json.Marshal(e)
        if err != nil </span><span class="cov0" title="0">{
                log.Get().Error(err)
                return "ErrValidation invalid."
        }</span>
        <span class="cov0" title="0">return string(body)</span>
}

// Add agrega errores a un validation error
func (e *ValidationErr) Add(path string, message string) Validation <span class="cov8" title="1">{
        err := errField{
                Path:    path,
                Message: message,
        }
        e.Messages = append(e.Messages, err)
        return e
}</span>

// errField define un campo inválido. path y mensaje de error
type errField struct {
        Path    string `json:"path"`
        Message string `json:"message"`
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package httpx

import "net/http"

type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

func Get(ctx ...interface{}) HTTPClient <span class="cov8" title="1">{
        for _, o := range ctx </span><span class="cov8" title="1">{
                if client, ok := o.(HTTPClient); ok </span><span class="cov8" title="1">{
                        return client
                }</span>
        }

        <span class="cov0" title="0">return http.DefaultClient</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./tools/httpx/client.go

// Package httpx is a generated GoMock package.
package httpx

import (
        http "net/http"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
)

// MockHTTPClient is a mock of HTTPClient interface.
type MockHTTPClient struct {
        ctrl     *gomock.Controller
        recorder *MockHTTPClientMockRecorder
}

// MockHTTPClientMockRecorder is the mock recorder for MockHTTPClient.
type MockHTTPClientMockRecorder struct {
        mock *MockHTTPClient
}

// NewMockHTTPClient creates a new mock instance.
func NewMockHTTPClient(ctrl *gomock.Controller) *MockHTTPClient <span class="cov8" title="1">{
        mock := &amp;MockHTTPClient{ctrl: ctrl}
        mock.recorder = &amp;MockHTTPClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHTTPClient) EXPECT() *MockHTTPClientMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Do mocks base method.
func (m *MockHTTPClient) Do(req *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Do", req)
        ret0, _ := ret[0].(*http.Response)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// Do indicates an expected call of Do.
func (mr *MockHTTPClientMockRecorder) Do(req interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Do", reflect.TypeOf((*MockHTTPClient)(nil).Do), req)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package redisx

import (
        "time"

        "github.com/go-redis/redis/v7"
        "github.com/nmarsollier/imagego/tools/env"
)

func Get(ctx ...interface{}) RedisClient <span class="cov8" title="1">{
        for _, o := range ctx </span><span class="cov8" title="1">{
                if client, ok := o.(RedisClient); ok </span><span class="cov8" title="1">{
                        return client
                }</span>
        }

        <span class="cov0" title="0">return redisClient{
                redis.NewClient(&amp;redis.Options{
                        Addr:     env.Get().RedisURL,
                        Password: "",
                        DB:       0,
                }),
        }</span>
}

type RedisClient interface {
        Get(key string) *redis.StringCmd
        Set(key string, value interface{}, expiration time.Duration) *redis.StatusCmd
}

type redisClient struct {
        client *redis.Client
}

func (c redisClient) Get(key string) *redis.StringCmd <span class="cov0" title="0">{
        return c.client.Get(key)
}</span>

func (c redisClient) Set(key string, value interface{}, expiration time.Duration) *redis.StatusCmd <span class="cov0" title="0">{
        return c.client.Set(key, value, expiration)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: ./tools/redisx/client.go

// Package redisx is a generated GoMock package.
package redisx

import (
        reflect "reflect"
        time "time"

        redis "github.com/go-redis/redis/v7"
        gomock "github.com/golang/mock/gomock"
)

// MockRedisClient is a mock of RedisClient interface.
type MockRedisClient struct {
        ctrl     *gomock.Controller
        recorder *MockRedisClientMockRecorder
}

// MockRedisClientMockRecorder is the mock recorder for MockRedisClient.
type MockRedisClientMockRecorder struct {
        mock *MockRedisClient
}

// NewMockRedisClient creates a new mock instance.
func NewMockRedisClient(ctrl *gomock.Controller) *MockRedisClient <span class="cov8" title="1">{
        mock := &amp;MockRedisClient{ctrl: ctrl}
        mock.recorder = &amp;MockRedisClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockRedisClient) EXPECT() *MockRedisClientMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// Get mocks base method.
func (m *MockRedisClient) Get(key string) *redis.StringCmd <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Get", key)
        ret0, _ := ret[0].(*redis.StringCmd)
        return ret0
}</span>

// Get indicates an expected call of Get.
func (mr *MockRedisClientMockRecorder) Get(key interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockRedisClient)(nil).Get), key)
}</span>

// Set mocks base method.
func (m *MockRedisClient) Set(key string, value interface{}, expiration time.Duration) *redis.StatusCmd <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "Set", key, value, expiration)
        ret0, _ := ret[0].(*redis.StatusCmd)
        return ret0
}</span>

// Set indicates an expected call of Set.
func (mr *MockRedisClientMockRecorder) Set(key, value, expiration interface{}) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockRedisClient)(nil).Set), key, value, expiration)
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package strs

import "encoding/json"

func ToJson(obj interface{}) string <span class="cov8" title="1">{
        jsonData, _ := json.Marshal(obj)
        return string(jsonData)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
